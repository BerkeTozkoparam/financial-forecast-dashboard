# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KIiqFh1QUlerBLEnd7bXbqgC29oWtPGj
"""

# app.py
import streamlit as st
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import plotly.express as px
import plotly.graph_objects as go

st.set_page_config(layout="wide")
st.title("ğŸ“Š Financial Forecasting Dashboard - Random Forest")

# 1. CSV Upload
uploaded_file = st.file_uploader("Upload your CSV file", type=["csv"])

if uploaded_file:
    df = pd.read_csv(uploaded_file)
    st.subheader("Data Preview")
    st.dataframe(df.head())

    # 2. Date Handling
    if 'Date' in df.columns:
        df['Date'] = pd.to_datetime(df['Date'])
        df = df.sort_values('Date')
        df['Year'] = df['Date'].dt.year
        df['Month'] = df['Date'].dt.month
        df['Day'] = df['Date'].dt.day

    # 3. One-hot encode categorical columns
    for col in df.select_dtypes(include=['object']).columns:
        if col != 'Date' and col != 'Close':
            df = pd.get_dummies(df, columns=[col], drop_first=True)

    # 4. Handle missing values
    df = df.dropna()

    # 5. Features and target
    feature_cols = [col for col in df.columns if col != 'Close' and col != 'Date']
    X = df[feature_cols]
    y = df['Close']

    # 6. Train-test split
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )

    # 7. Random Forest Model
    rf_model = RandomForestRegressor(
        n_estimators=200,
        max_depth=10,
        random_state=42,
        n_jobs=-1
    )
    rf_model.fit(X_train, y_train)
    y_pred = rf_model.predict(X_test)

    # 8. Metrics
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    r2 = r2_score(y_test, y_pred)

    st.subheader("Model Performance")
    col1, col2 = st.columns(2)
    col1.metric("RMSE", f"{rmse:.2f}")
    col2.metric("RÂ² Score", f"{r2:.2f}")

    # 9. Actual vs Predicted Time Series (Plotly)
    st.subheader("ğŸ“ˆ Actual vs Predicted Close Price")
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df['Date'].iloc[y_test.index], y=y_test.values,
                             mode='lines+markers', name='Actual', line=dict(color='blue')))
    fig.add_trace(go.Scatter(x=df['Date'].iloc[y_test.index], y=y_pred,
                             mode='lines+markers', name='Predicted', line=dict(color='red')))
    fig.update_layout(height=500, width=1000, xaxis_title='Date', yaxis_title='Close Price')
    st.plotly_chart(fig, use_container_width=True)

    # 10. Residuals
    residuals = y_test.values - y_pred
    st.subheader("ğŸ“Š Residuals")
    fig_res = px.histogram(residuals, nbins=50, title="Prediction Residuals")
    st.plotly_chart(fig_res, use_container_width=True)

    # 11. Feature Importance
    st.subheader("ğŸŒŸ Feature Importance")
    feat_imp = pd.DataFrame({
        'Feature': X_train.columns,
        'Importance': rf_model.feature_importances_
    }).sort_values(by='Importance', ascending=False)
    fig_feat = px.bar(feat_imp, x='Importance', y='Feature', orientation='h',
                      color='Importance', color_continuous_scale='Viridis')
    st.plotly_chart(fig_feat, use_container_width=True)

    # 12. Optional: Select date range for zoomed analysis
    st.subheader("ğŸ“… Zoom in on Date Range")
    start_date, end_date = st.date_input("Select range",
                                         [df['Date'].min(), df['Date'].max()])
    mask = (df['Date'] >= pd.to_datetime(start_date)) & (df['Date'] <= pd.to_datetime(end_date))
    df_range = df.loc[mask]
    st.dataframe(df_range)

